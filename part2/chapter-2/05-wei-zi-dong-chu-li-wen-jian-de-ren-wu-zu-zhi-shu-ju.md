# 05 为自动处理文件的任务组织数据

由于文件处理任务的自动化是生物信息学不可分割的一部分，组织我们的项目以促进这一工作至关重要。将数据组织到子目录中并使用清晰一致的文件命名方案势在必行。这种做法允许我们以编程方式引用文件，这是实现任务自动化的第一步。程序化操作是指通过代码而不是手动来完成，以及使用一种可以毫不费力地扩展到多个对象（如文件）的方法。通过编程引用多个文件比全部打出来更简单、更安全（因为不容易出错）

### shell扩展建议

* 生物信息学家、软件工程师和系统管理员花费大量时间在终端上打字。毫无疑问，这些人会利用各种技巧来使这个过程尽可能高效。随着在shell中花费的时间越来越多，你会发现在学习这些技巧上投入一点时间可以节省大量时间。
* 一个有用的技巧是shell扩展。Shell扩展是指Shell(例如，Bash，这可能是你正在使用的Shell)为你自动扩展文本，因此你不必将其输入。例如输入cd ~~以进入主目录，是shell将波浪字符(~~)扩展为到主目录的完整路径(如/Users/vinceb/)。像星号(`*`)这样的通配符也会被shell扩展到所有匹配的文件。
* 可以使用一种称为大括号展开的shell扩展类型，通过一个命令快速创建简单的zmay -snps/ project目录结构。大括号展开通过展开大括号内以逗号分隔的值来创建字符串。让我们通过一个小例子来理解
* 示例

```
$ echo dog-{gone,bowl,bark}
dog-gone dog-bowl dog-bark
```

使用同样的策略，我们可以创建zmay -snps/项目目录:

```bash
$ mkdir -p zmays-snps/{data/seqs,scripts,analysis}
```

这将产生与我们在“项目目录和目录结构”中用四个步骤构建的相同的zmay -snps布局:analysis/， data/seqs和scripts/。因为mkdir接受多个参数(为每个参数创建一个目录)，所以这创建了三个子目录(并且避免输入“zmayssnps/”三次)。注意，我们需要使用mkdir的-p标志，它告诉mkdir若父目录不存在，先创建父目录再创建子目录(在我们的例子中是data/到data/seqs/)。

我们将逐步练习一个简单的通配符示例，并在此过程中学习一些重要的shell通配符技巧。在本例中，将数据文件组织到具有一致文件名的单个目录中，使我们能够遍历所有数据，无论是本例中使用的四个示例文件，还是实际项目中的40,000个文件。这样想:还记得你发现可以用鼠标光标选择许多文件吗?有了这个技巧，你可以像移动6个文件一样轻松地移动60个文件。你也可以选择特定的文件类型(例如照片)，并通过一个动作将它们全部附加到电子邮件中。通过使用一致的文件命名和目录组织，可以使用Unix shell和其他编程语言以编程方式完成相同的工作。

### 通配符练习

下面我们将看到一个例子，使用 shell 通配符自动执行跨多个文件的自动化任务。在第 12 章稍后部分，我们将看到更高级的批量文件操作策略。

让我们创建一些虚假的空数据文件，看看一致的文件名如何帮助我们按编程方式处理文件。假设我们有三个玉米样本，"A"、"B"和 "C"，以及每个样本的PE测序数据：

```bash
$ cd data
$ touch seqs/zmays{A,B,C}_R{1,2}.fastq
$ ls seqs/
zmaysA_R1.fastq zmaysB_R1.fastq zmaysC_R1.fastq
zmaysA_R2.fastq zmaysB_R2.fastq zmaysC_R2.fastq
```

在此文件命名方案中，每个文件名的两个可变部分表示样本名称（zmaysA、zmaysB、zmaysC）和read（R1 和 R2）。假设我们想以编程方式检索样本名为 zmaysB 的所有文件（不管read是R1还是R2）而不是手动指定每个文件。为此，我们可以使用 Unix shell 通配符星号\* ：

```bash
$ ls seqs/zmaysB*
zmaysB_R1.fastq zmaysB_R2.fastq
```

通配符会扩展到所有匹配的文件或目录名（此过程称为 称为 "globbing"）。在上例中，shell 将表达式扩展为 zmaysB\_R1.fastq 和 zmaysB\_R2.fastq，因为这两个文件以zmaysB开头。如果该目录包含数百个 zmaysB 文件，那么所有这些文件都可以很容易地用 shell 通配符来引用和处理。

### 通配符和 "参数列表过长"

OS X 和 Linux 系统对命令的参数有限制（严格地说是对参数总长度的限制）。我们有时会在使用通配符匹配数以万计的文件时，看到一条 “Argument list too long” 的错误信息。表明你已经达到了限制。幸运的是，有一种巧妙的方法可以解决这个问题（请参阅第 411 页的 “Using find and xargs” 以了解解决方法）。

### 严格使用通配符

一般来说，最好尽可能严格使用通配符。这样可以防止意外匹配。例如，如果一个乱七八糟的同事创建了一个 Excel 文件，文件名为zmaysB-interesting-SNPs-found.xls，这将意外地匹配上面的通配符表达式 。如果需要处理所有的 zmaysB FASTQ 文件，使用原来的通配符将包括此 Excel 文件，从而导致问题。这就是为什么在使用通配符时最好尽可能限制。不要使用 ”zmaysB\*“、使用 `zmaysB*fastq`或者`zmaysB_R?.fastq`（?只匹配单个字符。

还有其他一些简单的 shell 通配符，在以编程方式 访问文件时很方便。假设一位合作者告诉你，C 样本序列的质量很差。所以在 C 样本重新测序时，你只能使用 A 和 B 样本。在收到新样本之前，你不想删除 zmaysC\_R1.fastq 和 zmaysC\_R2.fastq 文件。所以在此期间，你要忽略这些文件。发明通配符的人预见到了这样的问题，所以他们创建了 shell 通配符，允许你匹配特定字符或特定范围的字符。例如，我们可以用两个等价代码`[UVWXY]`或者`[U-Y]`来匹配字符 U、V、W、X 和 Y。

回到我们的例子，我们可以使用以下任一种方法排除 C 样本：

```bash
$ ls zmays[AB]_R1.fastq
zmaysA_R1.fastq zmaysB_R1.fastq
$ ls zmays[A-B]_R1.fastq
zmaysA_R1.fastq zmaysB_R1.fastq
```

使用 A 和 B 之间的范围其实没有必要，但如果我们有样本C到I，使用zmays\[C-I]\_R1这样的范围会比输入zmays\[CDEFGHI]\_R1.fastq好。有一个非常重要的注意事项：范围的操作对象是字符范围，而不是 13 到 30 这样的数字范围。这意味着通配符如`snps_[10-13].txt` 将无法匹配文件 snps\_10.txt、snps\_11.txt、snps\_12.txt 和snps\_13.txt。

不过，shell 确实为数字范围提供了一种扩展解决方案--通过我们前面看到的括号扩展。在了解这一快捷方式之前，请注意虽，然通配符匹配和括号扩展的行为看似相似，但它们之间略有不同。通配符只能扩展到与之匹配的现有字符串，而括号扩展则无论对应的文件或目录是否存在，都会展开。如果文件 snps\_10.txt 到 snps\_13.txt 确实存在，我们就可以用括号扩展序列表达式进行匹配，如 snps\_{10...13}.txt。这将扩展为整数序列 10 至 13（但请记住，这些文件是否存在并不通过括号扩展进行检查）

表 2-1 列出了常用的 Unix 通配符(直接粘贴图片)

<figure><img src="../../.gitbook/assets/Pasted image 20231101205457.png" alt=""><figcaption><p>表2-1</p></figcaption></figure>

[点此查看通配符使用](https://www.cnblogs.com/lixuwu/p/7816335.html)

现在，你应该开始了解 shell 通配符的作用了：它能让我们轻松处理多个文件。由于生物信息学的大量日常工作都涉及文件处理，以编程方式访问文件能让我们的工作更轻松，并消除因输入错误的文件名或忘记样本而造成的错误操作。不过，我们用通配符（或 R 或 Python 中的其他方法）编程访问文件的能力，只有在我们的文件名一致的情况下才有可能。虽然通配符功能强大，如果文件名不一致，通配符就毫无用处。例如，需要使用通配符来处理文件名为 zmays sampleA - 1.fastq, zmays\_sampleA-2.fastq, sampleB1.fastq、sample-B2.fastq 等的子集，由于这些文件名的不一致，处理起来就会变得更加复杂。不幸的是，命名不一致的现象在生物学中非常普遍，也是所有生物信息学家的灾难。总的来说，生物信息学家们可能已经浪费了成千上万个小时来与他人糟糕的文件、基因和代码命名方案作斗争。

### 前导零与排序

另一个有用的技巧是在命名文件时使用前导零（例如，fle-0021.txt 而不是而不是 fle-21.txt）。这很有用，因为命令对文件名逐个从头比较ASCII码进行排序（如 ls 所做的），从而获得正确的排序。例如，如果我们的文件名是 gene-1.txt、gene-2.txt、.....、gene-14.txt，按词典排序的结果是

```bash
$ ls -l
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:24 genes-1.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:24 genes-11.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:24 genes-12.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:24 genes-13.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:24 genes-14.txt
[...]
```

但如果使用前导零（如 gene-001.txt、gene-002.txt、.....、gene-014.txt），文件就会按正确的顺序排序

```bash
$ ls -l
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:23 genes-001.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:23 genes-002.txt
[...]
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:23 genes-013.txt
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:23 genes-014.txt
```

使用前导零不仅在命名文件名时有用，这也是命名基因、转录本等的最佳方法。像 Ensembl 这样的项目在命名基因时也使用了这种命名方案(ensg00000164256）。

除了简化文件的处理，统一的文件命名也是生物信息学中健壮性经常被忽视的组成部分。糟糕的样本命名方案很容易导致样本被调换。选择不当的文件名还可能在以下情况下导致严重错误：你或合作者认为使用的是正确的数据，但实际上是过时或错误的文件。我敢保证，在过去十年间发表的所有论文中，至少有几篇，甚至更多，因为文件命名问题而包含了错误的结果。
